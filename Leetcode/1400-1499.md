# Leetcode Problem 1400-1499

# [1413. Minimum Value to Get Positive Step by Step Sum](./1413_minimumValueToGetPositiveStepByStepSum.md) ðŸŒŸ

### PrefixSum O(N) Time

-   We calculate the running sum (prefix sum) of the array.
-   Every time we find minimum sum we got until now.
-   return abs(minimum sum) + 1.

---

# [1431. Kids With the Greatest Number of Candies](./1431_kidsWithTheGreatestNumberOfCandies.md) ðŸŒŸ

### O(N) Time and O(N) Space Solution:

-   Use greedy approach. For each kid check if candies[i] + extraCandies â‰¥ maximum in all Candies

---

# [1470. Shuffle the Array](./1470_shuffleTheArray.md) ðŸŒŸ

### O(N) Time and O(N) Space solution

-   Use two pointers to create the new array of 2n elements. The first starting at the beginning and the other starting at (n+1)th position. Alternate between them and create the new array.

---

# [1480. Running Sum of 1d Array](./1480_runningSumArr.md) ðŸŒŸ

### O(N) Time and O(N) Space solution

-   Create a sum variable to store current sum in it ans push back it in the result array.

### O(N) Time and O(1) Space optimization

-   We can modify input array directly

---

# [1493. Longest Subarray of 1's After Deleting One Element](./1493_LongestSubarrayof1'sAfterDeletingOneElement.md) ðŸŒŸðŸŒŸ

### Sliding Window

-   This question is same as [1004. Max Consecutive Ones III](./1004_maxConsecutiveOnesIII.md) ðŸŒŸðŸŒŸ
-   Here we just need to maintain a window of at most 1 zero.
-   return window size - 1, as we need to remove at least 1 element(either 0 or 1).
-   **TN**: O(N)
-   **SC**: O(1)

---
